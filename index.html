<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genome Reassembly Tool</title>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --accent: #ec4899;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-tertiary: #94a3b8;
            --border: #475569;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            padding: 1rem 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 0 2rem;
        }

        .tab-btn {
            padding: 1rem 2rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1rem;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
        }

        .tab-btn:hover {
            color: var(--text-primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .tab-btn.active {
            color: var(--primary);
            background: var(--bg-primary);
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary);
        }

        /* Tab Content */
        .tab-content {
            flex: 1;
            display: none;
            overflow: hidden;
        }

        .tab-content.active {
            display: flex;
        }

        /* Data Tab */
        .data-tab {
            padding: 2rem;
            overflow-y: auto;
        }

        .data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .data-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .data-panel h2 {
            color: var(--primary);
            margin-bottom: 1.5rem;
            font-size: 1.4rem;
        }

        .input-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .input-tab-btn {
            flex: 1;
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .input-tab-btn:hover {
            background: var(--primary);
            color: white;
        }

        .input-tab-btn.active {
            background: var(--primary);
            color: white;
        }

        .input-content {
            display: none;
        }

        .input-content.active {
            display: block;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
        }

        .file-input {
            display: none;
        }

        .file-label {
            display: block;
            padding: 3rem;
            background: var(--bg-tertiary);
            border: 2px dashed var(--border);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-label:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .textarea-input {
            width: 100%;
            min-height: 200px;
            padding: 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Consolas', monospace;
            resize: vertical;
        }

        .url-input-group {
            display: flex;
            gap: 1rem;
        }

        .url-input {
            flex: 1;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            background: var(--primary);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .demo-btn {
            width: 100%;
            padding: 1.5rem;
            background: linear-gradient(135deg, var(--accent), var(--secondary));
        }

        .process-section {
            grid-column: 1 / -1;
            text-align: center;
            margin-top: 2rem;
        }

        .process-btn {
            padding: 1rem 3rem;
            font-size: 1.1rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        /* Visualization Tab */
        .viz-tab {
            display: flex;
            height: 100%;
        }

        .viz-sidebar {
            width: 350px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-tabs {
            display: flex;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
        }

        .sidebar-tab {
            flex: 1;
            padding: 0.75rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.9rem;
        }

        .sidebar-tab.active {
            background: var(--bg-secondary);
            color: var(--primary);
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .sidebar-section {
            margin-bottom: 2rem;
        }

        .sidebar-section h3 {
            color: var(--primary);
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .tool-btn {
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        .tool-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .tool-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .tool-icon {
            font-size: 1.5rem;
        }

        .tool-name {
            font-size: 0.85rem;
        }

        .viz-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            overflow: hidden;
        }

        .viz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: 2rem;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .score-item {
            text-align: center;
        }

        .score-label {
            font-size: 0.85rem;
            color: var(--text-tertiary);
        }

        .score-value {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'Consolas', monospace;
            color: var(--success);
        }

        .viz-container {
            flex: 1;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 1.5rem;
            overflow: hidden;
        }

        .heatmap-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1rem;
            position: relative;
            overflow: hidden;
        }

        .heatmap-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #heatmap-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .selection-overlay {
            position: absolute;
            border: 3px solid var(--accent);
            background: rgba(236, 72, 153, 0.2);
            pointer-events: none;
            display: none;
        }

        .hover-info {
            position: absolute;
            background: rgba(30, 41, 59, 0.95);
            border: 1px solid var(--primary);
            border-radius: 6px;
            padding: 0.75rem;
            pointer-events: none;
            display: none;
            z-index: 100;
            font-size: 0.9rem;
        }

        .ps-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
        }

        .ps-panel h3 {
            margin-bottom: 1rem;
            color: var(--primary);
        }

        #ps-plot {
            width: 100%;
            height: 300px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .history-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-item:hover {
            background: var(--primary);
            transform: translateX(5px);
        }

        .history-score {
            font-family: 'Consolas', monospace;
            color: var(--success);
        }

        /* Export Tab */
        .export-tab {
            padding: 2rem;
            max-width: 800px;
            margin: 0 auto;
        }

        .export-section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .export-section h2 {
            color: var(--primary);
            margin-bottom: 1.5rem;
        }

        .export-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .export-btn {
            padding: 1rem;
            background: var(--success);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .export-btn:hover {
            background: #059669;
            transform: translateY(-2px);
        }

        .export-icon {
            font-size: 2rem;
        }

        /* Settings Panel */
        .settings-group {
            margin-bottom: 1.5rem;
        }

        .settings-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .settings-group select,
        .settings-group input[type="number"] {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
        }

        .settings-group input[type="range"] {
            width: 100%;
            margin-top: 0.5rem;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Loading */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--bg-tertiary);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Status Bar */
        .status-bar {
            display: flex;
            gap: 1rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-primary);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .status-icon {
            font-size: 1.2rem;
        }

        .status-item.loaded {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--success);
        }

        .status-item.loaded .status-icon {
            color: var(--success);
        }

        /* Region Info */
        .region-info {
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .region-info h4 {
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        .region-details {
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Operation Controls */
        .operation-controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .control-btn {
            flex: 1;
            padding: 0.5rem;
            font-size: 0.85rem;
        }

        .control-btn.confirm {
            background: var(--success);
        }

        .control-btn.cancel {
            background: var(--danger);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1>🧬 Genome Reassembly Tool</h1>
        </header>

        <nav class="tab-nav">
            <button class="tab-btn active" data-tab="data">📊 Data Input</button>
            <button class="tab-btn" data-tab="viz">🔬 Visualization & Editing</button>
            <button class="tab-btn" data-tab="export">💾 Export</button>
        </nav>

        <!-- Data Input Tab -->
        <div class="tab-content active" id="data-tab">
            <div class="data-tab">
                <div class="data-grid">
                    <div class="data-panel">
                        <h2>Reference Genome (FASTA)</h2>
                        <div class="input-tabs">
                            <button class="input-tab-btn active" data-input="fasta-upload">Upload</button>
                            <button class="input-tab-btn" data-input="fasta-paste">Paste</button>
                            <button class="input-tab-btn" data-input="fasta-url">URL</button>
                            <button class="input-tab-btn" data-input="fasta-demo">Demo</button>
                        </div>
                        <div class="input-content active" id="fasta-upload">
                            <div class="file-input-wrapper">
                                <input type="file" id="fasta-file" class="file-input" accept=".fasta,.fa,.fna,.txt">
                                <label for="fasta-file" class="file-label">
                                    <div>📁 Choose FASTA file</div>
                                    <div style="font-size: 0.9rem; color: var(--text-tertiary); margin-top: 0.5rem;">or drag and drop here</div>
                                </label>
                            </div>
                        </div>
                        <div class="input-content" id="fasta-paste">
                            <textarea class="textarea-input" placeholder="Paste FASTA content here..."></textarea>
                        </div>
                        <div class="input-content" id="fasta-url">
                            <div class="url-input-group">
                                <input type="url" class="url-input" placeholder="Enter FASTA URL...">
                                <button class="btn">Fetch</button>
                            </div>
                        </div>
                        <div class="input-content" id="fasta-demo">
                            <button class="btn demo-btn">Load Demo Genome</button>
                        </div>
                    </div>

                    <div class="data-panel">
                        <h2>Contact Map (BED/Matrix)</h2>
                        <div class="input-tabs">
                            <button class="input-tab-btn active" data-input="bed-upload">Upload</button>
                            <button class="input-tab-btn" data-input="bed-paste">Paste</button>
                            <button class="input-tab-btn" data-input="bed-url">URL</button>
                            <button class="input-tab-btn" data-input="bed-demo">Demo</button>
                        </div>
                        <div class="input-content active" id="bed-upload">
                            <div class="file-input-wrapper">
                                <input type="file" id="bed-file" class="file-input" accept=".bed,.txt,.gz,.zip">
                                <label for="bed-file" class="file-label">
                                    <div>📊 Choose BED/Matrix file</div>
                                    <div style="font-size: 0.9rem; color: var(--text-tertiary); margin-top: 0.5rem;">or drag and drop here</div>
                                </label>
                            </div>
                        </div>
                        <div class="input-content" id="bed-paste">
                            <textarea class="textarea-input" placeholder="Paste BED/Matrix content here..."></textarea>
                        </div>
                        <div class="input-content" id="bed-url">
                            <div class="url-input-group">
                                <input type="url" class="url-input" placeholder="Enter BED/Matrix URL...">
                                <button class="btn">Fetch</button>
                            </div>
                        </div>
                        <div class="input-content" id="bed-demo">
                            <button class="btn demo-btn">Load Demo Contact Map</button>
                        </div>
                    </div>

                    <div class="process-section">
                        <div class="status-bar">
                            <div class="status-item" id="fasta-status">
                                <span class="status-icon">⚪</span>
                                <span>FASTA: Not loaded</span>
                            </div>
                            <div class="status-item" id="bed-status">
                                <span class="status-icon">⚪</span>
                                <span>Contact Map: Not loaded</span>
                            </div>
                        </div>
                        <button class="btn process-btn" id="process-btn">🚀 Process Data</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Visualization Tab -->
        <div class="tab-content" id="viz-tab">
            <div class="viz-tab">
                <aside class="viz-sidebar">
                    <div class="sidebar-tabs">
                        <button class="sidebar-tab active" data-sidebar="tools">Tools</button>
                        <button class="sidebar-tab" data-sidebar="history">History</button>
                        <button class="sidebar-tab" data-sidebar="settings">Settings</button>
                    </div>
                    
                    <div class="sidebar-content">
                        <!-- Tools Panel -->
                        <div class="sidebar-panel active" id="tools-panel">
                            <div class="sidebar-section">
                                <h3>Editing Tools</h3>
                                <div class="tool-grid">
                                    <button class="tool-btn active" data-tool="select">
                                        <span class="tool-icon">⬚</span>
                                        <span class="tool-name">Select</span>
                                    </button>
                                    <button class="tool-btn" data-tool="move">
                                        <span class="tool-icon">↔️</span>
                                        <span class="tool-name">Move</span>
                                    </button>
                                    <button class="tool-btn" data-tool="invert">
                                        <span class="tool-icon">🔄</span>
                                        <span class="tool-name">Invert</span>
                                    </button>
                                    <button class="tool-btn" data-tool="delete">
                                        <span class="tool-icon">🗑️</span>
                                        <span class="tool-name">Delete</span>
                                    </button>
                                    <button class="tool-btn" data-tool="duplicate">
                                        <span class="tool-icon">📋</span>
                                        <span class="tool-name">Duplicate</span>
                                    </button>
                                    <button class="tool-btn" data-tool="split">
                                        <span class="tool-icon">✂️</span>
                                        <span class="tool-name">Split</span>
                                    </button>
                                    <button class="tool-btn" data-tool="fuse">
                                        <span class="tool-icon">🔗</span>
                                        <span class="tool-name">Fuse</span>
                                    </button>
                                    <button class="tool-btn" data-tool="swap">
                                        <span class="tool-icon">🔀</span>
                                        <span class="tool-name">Swap</span>
                                    </button>
                                </div>
                            </div>

                            <div class="sidebar-section">
                                <h3>Selected Region</h3>
                                <div class="region-info" id="region-info">
                                    <p style="color: var(--text-tertiary);">No region selected</p>
                                </div>
                                <div class="operation-controls" id="operation-controls" style="display: none;">
                                    <button class="btn control-btn confirm" id="confirm-op">✓ Confirm</button>
                                    <button class="btn control-btn cancel" id="cancel-op">✗ Cancel</button>
                                </div>
                            </div>
                        </div>

                        <!-- History Panel -->
                        <div class="sidebar-panel" id="history-panel" style="display: none;">
                            <div class="sidebar-section">
                                <h3>Edit History</h3>
                                <div class="history-list" id="history-list">
                                    <!-- History items will be added here -->
                                </div>
                            </div>
                        </div>

                        <!-- Settings Panel -->
                        <div class="sidebar-panel" id="settings-panel" style="display: none;">
                            <div class="sidebar-section">
                                <h3>Visualization Settings</h3>
                                
                                <div class="settings-group">
                                    <label>Transform</label>
                                    <select id="transform-select">
                                        <option value="linear">Linear</option>
                                        <option value="log" selected>Log</option>
                                        <option value="log2">Log2</option>
                                        <option value="sqrt">Square Root</option>
                                    </select>
                                </div>

                                <div class="settings-group">
                                    <label>Color Scheme</label>
                                    <select id="colorscheme-select">
                                        <option value="viridis">Viridis</option>
                                        <option value="plasma">Plasma</option>
                                        <option value="inferno">Inferno</option>
                                        <option value="turbo" selected>Turbo</option>
                                        <option value="hot">Hot</option>
                                        <option value="cool">Cool</option>
                                    </select>
                                </div>

                                <div class="settings-group">
                                    <label>Min Value: <span id="vmin-label">0</span></label>
                                    <input type="range" id="vmin-slider" min="0" max="100" value="0">
                                </div>

                                <div class="settings-group">
                                    <label>Max Value: <span id="vmax-label">100</span></label>
                                    <input type="range" id="vmax-slider" min="1" max="1000" value="100">
                                </div>

                                <div class="settings-group">
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="percentile-clip">
                                        <label for="percentile-clip">Auto clip (95th percentile)</label>
                                    </div>
                                </div>

                                <div class="settings-group">
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="grid-toggle" checked>
                                        <label for="grid-toggle">Show chromosome boundaries</label>
                                    </div>
                                </div>

                                <div class="settings-group">
                                    <div class="checkbox-group">
                                        <input type="checkbox" id="diagonal-toggle">
                                        <label for="diagonal-toggle">Show diagonal</label>
                                    </div>
                                </div>

                                <button class="btn" id="apply-settings" style="width: 100%; margin-top: 1rem;">Apply Settings</button>
                            </div>
                        </div>
                    </div>
                </aside>

                <main class="viz-main">
                    <div class="viz-header">
                        <h2>Contact Map Visualization</h2>
                        <div class="score-display">
                            <div class="score-item">
                                <div class="score-label">Current Score</div>
                                <div class="score-value" id="current-score">0.00</div>
                            </div>
                            <div class="score-item">
                                <div class="score-label">Best Score</div>
                                <div class="score-value" id="best-score" style="color: var(--accent);">0.00</div>
                            </div>
                            <div class="score-item">
                                <div class="score-label">Alpha</div>
                                <div class="score-value" id="alpha-value" style="color: var(--warning);">-1.00</div>
                            </div>
                        </div>
                    </div>

                    <div class="viz-container">
                        <div class="heatmap-panel">
                            <div class="heatmap-wrapper">
                                <canvas id="heatmap-canvas"></canvas>
                                <div class="selection-overlay" id="selection-overlay"></div>
                                <div class="hover-info" id="hover-info">
                                    <div class="hover-coords"></div>
                                    <div class="hover-value"></div>
                                </div>
                            </div>
                        </div>

                        <div class="ps-panel">
                            <h3>P(s) Distribution</h3>
                            <canvas id="ps-plot"></canvas>
                            <div style="text-align: center; margin-top: 1rem; font-family: 'Consolas', monospace;">
                                P(s) ~ s<sup id="ps-alpha">-1.0</sup>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
        </div>

        <!-- Export Tab -->
        <div class="tab-content" id="export-tab">
            <div class="export-tab">
                <div class="export-section">
                    <h2>Export Options</h2>
                    <div class="export-grid">
                        <button class="export-btn" id="export-bed">
                            <span class="export-icon">📊</span>
                            <span>Export BED</span>
                        </button>
                        <button class="export-btn" id="export-modifications">
                            <span class="export-icon">📝</span>
                            <span>Export Modifications</span>
                        </button>
                        <button class="export-btn" id="export-fasta">
                            <span class="export-icon">🧬</span>
                            <span>Export FASTA</span>
                        </button>
                        <button class="export-btn" id="export-matrix">
                            <span class="export-icon">🔢</span>
                            <span>Export Matrix</span>
                        </button>
                    </div>
                </div>

                <div class="export-section">
                    <h2>Summary Statistics</h2>
                    <div id="export-summary">
                        <p style="color: var(--text-tertiary);">No data processed yet</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loading" style="display: none;">
        <div class="loading-spinner"></div>
    </div>

    <script>
    class GenomeReassemblyTool {
        constructor() {
            this.fastaData = null;
            this.contactMap = null;
            this.chromosomes = [];
            this.binSize = 1000000;
            this.currentState = null;
            this.history = [];
            this.historyIndex = -1;
            this.selectedTool = 'select';
            this.selection = null;
            this.pendingOperation = null;
            
            this.vizSettings = {
                transform: 'log',
                colorScheme: 'turbo',
                vmin: 0,
                vmax: 100,
                percentileClip: false,
                showGrid: true,
                showDiagonal: false
            };
            
            this.colorSchemes = {
                viridis: [[68, 1, 84], [72, 40, 120], [62, 73, 137], [49, 104, 142], [38, 130, 142], [31, 158, 137], [53, 183, 121], [109, 205, 89], [180, 222, 44], [253, 231, 37]],
                plasma: [[13, 8, 135], [84, 2, 163], [139, 10, 165], [185, 50, 137], [219, 92, 104], [244, 136, 73], [254, 188, 43], [240, 249, 33]],
                inferno: [[0, 0, 4], [40, 11, 84], [101, 21, 110], [159, 42, 99], [212, 72, 66], [245, 125, 21], [250, 193, 39], [252, 255, 164]],
                turbo: [[48, 18, 59], [68, 124, 202], [41, 188, 219], [65, 225, 92], [184, 225, 30], [251, 191, 39], [245, 99, 32], [189, 36, 40], [122, 4, 3]],
                hot: [[10, 0, 0], [178, 0, 0], [255, 51, 0], [255, 178, 0], [255, 255, 51], [255, 255, 178], [255, 255, 255]],
                cool: [[0, 255, 255], [255, 0, 255]]
            };
            
            this.initializeEventListeners();
        }
        
        initializeEventListeners() {
            // Tab navigation
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    e.target.classList.add('active');
                    document.getElementById(`${e.target.dataset.tab}-tab`).classList.add('active');
                });
            });
            
            // Input tabs
            document.querySelectorAll('.input-tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const input = e.target.dataset.input;
                    const panel = e.target.closest('.data-panel');
                    
                    panel.querySelectorAll('.input-tab-btn').forEach(b => b.classList.remove('active'));
                    panel.querySelectorAll('.input-content').forEach(c => c.classList.remove('active'));
                    
                    e.target.classList.add('active');
                    panel.querySelector(`#${input}`).classList.add('active');
                });
            });
            
            // Sidebar tabs
            document.querySelectorAll('.sidebar-tab').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.sidebar-tab').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.sidebar-panel').forEach(p => p.style.display = 'none');
                    
                    e.target.classList.add('active');
                    document.getElementById(`${e.target.dataset.sidebar}-panel`).style.display = 'block';
                });
            });
            
            // File inputs
            document.getElementById('fasta-file').addEventListener('change', (e) => this.handleFileUpload(e, 'fasta'));
            document.getElementById('bed-file').addEventListener('change', (e) => this.handleFileUpload(e, 'bed'));
            
            // Demo buttons
            document.querySelectorAll('.demo-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    if (e.target.closest('#fasta-demo')) {
                        this.loadDemoFasta();
                    } else {
                        this.loadDemoBed();
                    }
                });
            });
            
            // Process button
            document.getElementById('process-btn').addEventListener('click', () => this.processData());
            
            // Tool buttons
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    e.currentTarget.classList.add('active');
                    this.selectedTool = e.currentTarget.dataset.tool;
                });
            });
            
            // Canvas events
            const canvas = document.getElementById('heatmap-canvas');
            canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
            canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
            canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
            canvas.addEventListener('mouseleave', () => this.hideHoverInfo());
            
            // Operation controls
            document.getElementById('confirm-op').addEventListener('click', () => this.confirmOperation());
            document.getElementById('cancel-op').addEventListener('click', () => this.cancelOperation());
            
            // Settings
            this.initializeSettings();
            
            // Export buttons
            document.getElementById('export-bed').addEventListener('click', () => this.exportBed());
            document.getElementById('export-modifications').addEventListener('click', () => this.exportModifications());
            document.getElementById('export-fasta').addEventListener('click', () => this.exportFasta());
            document.getElementById('export-matrix').addEventListener('click', () => this.exportMatrix());
        }
        
        initializeSettings() {
            document.getElementById('transform-select').addEventListener('change', (e) => {
                this.vizSettings.transform = e.target.value;
            });
            
            document.getElementById('colorscheme-select').addEventListener('change', (e) => {
                this.vizSettings.colorScheme = e.target.value;
            });
            
            document.getElementById('vmin-slider').addEventListener('input', (e) => {
                this.vizSettings.vmin = parseFloat(e.target.value);
                document.getElementById('vmin-label').textContent = e.target.value;
            });
            
            document.getElementById('vmax-slider').addEventListener('input', (e) => {
                this.vizSettings.vmax = parseFloat(e.target.value);
                document.getElementById('vmax-label').textContent = e.target.value;
            });
            
            document.getElementById('percentile-clip').addEventListener('change', (e) => {
                this.vizSettings.percentileClip = e.target.checked;
            });
            
            document.getElementById('grid-toggle').addEventListener('change', (e) => {
                this.vizSettings.showGrid = e.target.checked;
            });
            
            document.getElementById('diagonal-toggle').addEventListener('change', (e) => {
                this.vizSettings.showDiagonal = e.target.checked;
            });
            
            document.getElementById('apply-settings').addEventListener('click', () => {
                if (this.currentState) this.render();
            });
        }
        
        async handleFileUpload(e, type) {
            const file = e.target.files[0];
            if (!file) return;
            
            this.showLoading();
            
            try {
                const content = await this.readFile(file);
                
                if (type === 'fasta') {
                    this.fastaData = this.parseFasta(content);
                    this.updateStatus('fasta', true, `${Object.keys(this.fastaData).length} sequences`);
                } else {
                    this.contactMap = await this.parseContactMap(content);
                    this.updateStatus('bed', true, `${this.contactMap.matrix.length}×${this.contactMap.matrix.length} matrix`);
                }
            } catch (error) {
                alert('Error reading file: ' + error.message);
            } finally {
                this.hideLoading();
            }
        }
        
        readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }
        
        updateStatus(type, loaded, info) {
            const status = document.getElementById(`${type}-status`);
            if (loaded) {
                status.classList.add('loaded');
                status.querySelector('.status-icon').textContent = '✅';
                status.innerHTML = `<span class="status-icon">✅</span><span>${type.toUpperCase()}: ${info}</span>`;
            }
        }
        
        parseFasta(content) {
            const sequences = {};
            let currentHeader = null;
            let currentSequence = [];
            
            content.split('\n').forEach(line => {
                line = line.trim();
                if (line.startsWith('>')) {
                    if (currentHeader) {
                        sequences[currentHeader] = currentSequence.join('');
                    }
                    currentHeader = line.substring(1).split(/\s+/)[0];
                    currentSequence = [];
                } else if (line) {
                    currentSequence.push(line);
                }
            });
            
            if (currentHeader) {
                sequences[currentHeader] = currentSequence.join('');
            }
            
            return sequences;
        }
        
        async parseContactMap(content) {
            const lines = content.trim().split('\n').filter(line => line.trim() && !line.startsWith('#'));
            
            // Detect if it's a matrix format
            if (this.isSquareMatrix(lines)) {
                return this.parseMatrixFormat(lines);
            } else {
                return this.parseBedFormat(lines);
            }
        }
        
        isSquareMatrix(lines) {
            if (lines.length < 10) return false;
            const firstRowCols = lines[0].split(/\s+/).length;
            return lines.length === firstRowCols && !isNaN(parseFloat(lines[0].split(/\s+/)[0]));
        }
        
        parseMatrixFormat(lines) {
            const size = lines.length;
            const matrix = lines.map(line => 
                line.split(/\s+/).map(v => parseFloat(v) || 0)
            );
            
            // Generate synthetic chromosome assignments
            const binSize = Math.ceil(size / 3);
            const chromosomes = ['chr1', 'chr2', 'chr3'];
            const binMap = new Map();
            
            let binId = 0;
            chromosomes.forEach((chr, i) => {
                const start = i * binSize;
                const end = Math.min((i + 1) * binSize, size);
                
                for (let j = start; j < end; j++) {
                    binMap.set(`${chr}:${j * this.binSize}-${(j + 1) * this.binSize}`, binId++);
                }
            });
            
            this.chromosomes = chromosomes;
            
            return { matrix, binMap, chromosomes };
        }
        
        parseBedFormat(lines) {
            const data = [];
            
            lines.forEach(line => {
                const parts = line.split(/\s+/);
                if (parts.length >= 6) {
                    data.push({
                        chr1: parts[0],
                        start1: parseInt(parts[1]),
                        end1: parseInt(parts[2]),
                        chr2: parts[3],
                        start2: parseInt(parts[4]),
                        end2: parseInt(parts[5]),
                        score: parseFloat(parts[6]) || 1
                    });
                }
            });
            
            return this.processContactMapData(data);
        }
        
        processContactMapData(data) {
            const chrSet = new Set();
            data.forEach(d => {
                chrSet.add(d.chr1);
                chrSet.add(d.chr2);
            });
            
            this.chromosomes = Array.from(chrSet).sort((a, b) => {
                const aNum = parseInt(a.replace(/\D/g, '')) || 999;
                const bNum = parseInt(b.replace(/\D/g, '')) || 999;
                return aNum - bNum;
            });
            
            const binMap = new Map();
            let binId = 0;
            
            this.chromosomes.forEach(chr => {
                const chrData = data.filter(d => d.chr1 === chr || d.chr2 === chr);
                const positions = new Set();
                
                chrData.forEach(d => {
                    if (d.chr1 === chr) {
                        positions.add(d.start1);
                        positions.add(d.end1);
                    }
                    if (d.chr2 === chr) {
                        positions.add(d.start2);
                        positions.add(d.end2);
                    }
                });
                
                const sortedPos = Array.from(positions).sort((a, b) => a - b);
                
                for (let i = 0; i < sortedPos.length - 1; i++) {
                    binMap.set(`${chr}:${sortedPos[i]}-${sortedPos[i + 1]}`, binId++);
                }
            });
            
            const matrixSize = binId;
            const matrix = Array(matrixSize).fill(null).map(() => Array(matrixSize).fill(0));
            
            data.forEach(d => {
                const bin1 = binMap.get(`${d.chr1}:${d.start1}-${d.end1}`);
                const bin2 = binMap.get(`${d.chr2}:${d.start2}-${d.end2}`);
                
                if (bin1 !== undefined && bin2 !== undefined) {
                    matrix[bin1][bin2] = d.score;
                    matrix[bin2][bin1] = d.score;
                }
            });
            
            return { matrix, binMap, chromosomes: this.chromosomes, originalData: data };
        }
        
        loadDemoFasta() {
            this.showLoading();
            
            const demoFasta = `>chr1
ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
>chr2
GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA
GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA
>chr3
TACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACG
TACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACG`;
            
            this.fastaData = this.parseFasta(demoFasta);
            this.updateStatus('fasta', true, '3 sequences');
            
            setTimeout(() => this.hideLoading(), 500);
        }
        
        loadDemoBed() {
            this.showLoading();
            
            const size = 100;
            const matrix = Array(size).fill(null).map(() => Array(size).fill(0));
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const distance = Math.abs(i - j);
                    const value = distance === 0 ? 100 : 100 * Math.pow(distance + 1, -1.5) + Math.random() * 5;
                    matrix[i][j] = value;
                    matrix[j][i] = value;
                }
            }
            
            const chrBlocks = [
                {start: 0, end: 30, chr: 'chr1'},
                {start: 30, end: 65, chr: 'chr2'},
                {start: 65, end: 100, chr: 'chr3'}
            ];
            
            chrBlocks.forEach(block => {
                for (let i = block.start; i < block.end; i++) {
                    for (let j = block.start; j < block.end; j++) {
                        matrix[i][j] *= 2;
                    }
                }
            });
            
            const binMap = new Map();
            let binId = 0;
            chrBlocks.forEach(block => {
                for (let i = block.start; i < block.end; i++) {
                    binMap.set(`${block.chr}:${i * this.binSize}-${(i + 1) * this.binSize}`, binId++);
                }
            });
            
            this.chromosomes = ['chr1', 'chr2', 'chr3'];
            this.contactMap = { matrix, binMap, chromosomes: this.chromosomes };
            
            this.updateStatus('bed', true, '100×100 matrix');
            
            setTimeout(() => this.hideLoading(), 500);
        }
        
        async processData() {
            if (!this.contactMap) {
                alert('Please load a contact map first');
                return;
            }
            
            this.showLoading();
            
            try {
                this.currentState = {
                    matrix: this.contactMap.matrix,
                    binOrder: Array.from({length: this.contactMap.matrix.length}, (_, i) => i),
                    score: 0,
                    psData: null
                };
                
                this.calculatePsDistribution();
                this.calculateScore();
                
                this.saveToHistory('Initial state');
                
                document.querySelector('[data-tab="viz"]').click();
                
                this.render();
            } catch (error) {
                alert('Error processing data: ' + error.message);
            } finally {
                this.hideLoading();
            }
        }
        
        calculatePsDistribution() {
            const matrix = this.currentState.matrix;
            const order = this.currentState.binOrder;
            const size = matrix.length;
            
            const distanceCounts = new Map();
            
            for (let i = 0; i < size; i++) {
                for (let j = i; j < size; j++) {
                    const distance = Math.abs(i - j);
                    const contact = matrix[order[i]][order[j]];
                    
                    if (!distanceCounts.has(distance)) {
                        distanceCounts.set(distance, { sum: 0, count: 0 });
                    }
                    
                    distanceCounts.get(distance).sum += contact;
                    distanceCounts.get(distance).count += 1;
                }
            }
            
            const psData = [];
            distanceCounts.forEach((value, distance) => {
                if (distance > 0) {
                    psData.push({
                        s: distance,
                        p: value.sum / value.count
                    });
                }
            });
            
            psData.sort((a, b) => a.s - b.s);
            
            // Robust power law fitting - exclude outliers
            const logData = psData
                .filter(d => d.p > 0 && d.s > 1 && d.s < size * 0.8) // Exclude very close and very far bins
                .map(d => ({
                    x: Math.log(d.s),
                    y: Math.log(d.p)
                }));
            
            if (logData.length > 2) {
                // Use RANSAC-like approach for robust fitting
                let bestAlpha = -1;
                let bestInliers = 0;
                
                for (let iter = 0; iter < 100; iter++) {
                    // Sample two random points
                    const idx1 = Math.floor(Math.random() * logData.length);
                    const idx2 = Math.floor(Math.random() * logData.length);
                    if (idx1 === idx2) continue;
                    
                    // Calculate slope
                    const alpha = -(logData[idx2].y - logData[idx1].y) / (logData[idx2].x - logData[idx1].x);
                    
                    // Count inliers
                    const intercept = logData[idx1].y + alpha * logData[idx1].x;
                    let inliers = 0;
                    
                    logData.forEach(d => {
                        const predicted = intercept - alpha * d.x;
                        const error = Math.abs(predicted - d.y);
                        if (error < 0.5) inliers++;
                    });
                    
                    if (inliers > bestInliers) {
                        bestInliers = inliers;
                        bestAlpha = alpha;
                    }
                }
                
                this.currentState.psData = {
                    data: psData,
                    alpha: bestAlpha
                };
            }
        }
        
        calculateScore() {
            if (!this.currentState.psData) {
                this.currentState.score = 0;
                return;
            }
            
            // Score based on power law fit quality and alpha value
            const idealAlpha = 1.0;
            const alpha = this.currentState.psData.alpha;
            const alphaDiff = Math.abs(alpha - idealAlpha);
            const alphaScore = 100 / (1 + alphaDiff * alphaDiff);
            
            // Calculate R² for power law fit
            const psData = this.currentState.psData.data;
            const logData = psData
                .filter(d => d.p > 0 && d.s > 1 && d.s < psData.length * 0.8)
                .map(d => ({
                    x: Math.log(d.s),
                    y: Math.log(d.p),
                    predicted: Math.log(100) - alpha * Math.log(d.s)
                }));
            
            const meanY = logData.reduce((sum, d) => sum + d.y, 0) / logData.length;
            const ssTotal = logData.reduce((sum, d) => sum + Math.pow(d.y - meanY, 2), 0);
            const ssResidual = logData.reduce((sum, d) => sum + Math.pow(d.y - d.predicted, 2), 0);
            const r2 = 1 - (ssResidual / ssTotal);
            const fitScore = Math.max(0, r2) * 100;
            
            // Diagonal enrichment score
            const matrix = this.currentState.matrix;
            const order = this.currentState.binOrder;
            let diagonalSum = 0;
            let totalSum = 0;
            
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix.length; j++) {
                    const value = matrix[order[i]][order[j]];
                    totalSum += value;
                    if (Math.abs(i - j) <= 5) {
                        diagonalSum += value;
                    }
                }
            }
            
            const diagonalScore = (diagonalSum / totalSum) * 100;
            
            // Combined score with weights
            this.currentState.score = 0.4 * alphaScore + 0.4 * fitScore + 0.2 * diagonalScore;
            
            this.updateScoreDisplay();
        }
        
        updateScoreDisplay() {
            document.getElementById('current-score').textContent = this.currentState.score.toFixed(2);
            document.getElementById('alpha-value').textContent = this.currentState.psData?.alpha.toFixed(2) || '-1.00';
            document.getElementById('ps-alpha').textContent = this.currentState.psData?.alpha.toFixed(2) || '-1.0';
            
            // Update best score
            const bestScore = Math.max(...this.history.map(h => h.state.score || 0), this.currentState.score);
            document.getElementById('best-score').textContent = bestScore.toFixed(2);
        }
        
        saveToHistory(description) {
            // Trim future history if we're not at the end
            if (this.historyIndex < this.history.length - 1) {
                this.history = this.history.slice(0, this.historyIndex + 1);
            }
            
            // Save compressed state
            const compressedState = {
                binOrder: [...this.currentState.binOrder],
                score: this.currentState.score,
                psAlpha: this.currentState.psData?.alpha
            };
            
            this.history.push({
                description,
                timestamp: new Date().toISOString(),
                state: compressedState
            });
            
            this.historyIndex = this.history.length - 1;
            
            // Keep only last 50 states
            if (this.history.length > 50) {
                this.history = this.history.slice(-50);
                this.historyIndex = this.history.length - 1;
            }
            
            this.updateHistoryPanel();
        }
        
        updateHistoryPanel() {
            const historyList = document.getElementById('history-list');
            historyList.innerHTML = '';
            
            this.history.slice().reverse().forEach((item, idx) => {
                const actualIdx = this.history.length - 1 - idx;
                const div = document.createElement('div');
                div.className = 'history-item';
                if (actualIdx === this.historyIndex) {
                    div.style.background = 'var(--primary)';
                }
                
                div.innerHTML = `
                    <div>
                        <div style="font-weight: 600;">${item.description}</div>
                        <div style="font-size: 0.8rem; color: var(--text-tertiary);">
                            ${new Date(item.timestamp).toLocaleTimeString()}
                        </div>
                    </div>
                    <div class="history-score">${item.state.score.toFixed(2)}</div>
                `;
                
                div.addEventListener('click', () => this.loadFromHistory(actualIdx));
                historyList.appendChild(div);
            });
        }
        
        loadFromHistory(index) {
            if (index < 0 || index >= this.history.length) return;
            
            const item = this.history[index];
            this.currentState.binOrder = [...item.state.binOrder];
            this.currentState.score = item.state.score;
            
            this.calculatePsDistribution();
            this.calculateScore();
            
            this.historyIndex = index;
            this.updateHistoryPanel();
            this.render();
        }
        
        render() {
            if (!this.currentState) return;
            
            this.renderHeatmap();
            this.renderPsPlot();
            this.updateScoreDisplay();
        }
        
        transformValue(value) {
            if (value <= 0) return 0;
            
            switch (this.vizSettings.transform) {
                case 'linear': return value;
                case 'log': return Math.log(value + 1);
                case 'log2': return Math.log2(value + 1);
                case 'sqrt': return Math.sqrt(value);
                default: return value;
            }
        }
        
        getColor(value, minVal, maxVal) {
            const transformed = this.transformValue(value);
            const minTransformed = this.transformValue(minVal);
            const maxTransformed = this.transformValue(maxVal);
            
            let normalized = (transformed - minTransformed) / (maxTransformed - minTransformed);
            normalized = Math.max(0, Math.min(1, normalized));
            
            const scheme = this.colorSchemes[this.vizSettings.colorScheme];
            const index = normalized * (scheme.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            const fraction = index - lower;
            
            const r = Math.round(scheme[lower][0] * (1 - fraction) + scheme[upper][0] * fraction);
            const g = Math.round(scheme[lower][1] * (1 - fraction) + scheme[upper][1] * fraction);
            const b = Math.round(scheme[lower][2] * (1 - fraction) + scheme[upper][2] * fraction);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        renderHeatmap() {
            const canvas = document.getElementById('heatmap-canvas');
            const ctx = canvas.getContext('2d');
            const matrix = this.currentState.matrix;
            const order = this.currentState.binOrder;
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const size = matrix.length;
            const cellSize = canvas.width / size;
            
            // Clear canvas
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate value range
            let minValue = this.vizSettings.vmin;
            let maxValue = this.vizSettings.vmax;
            
            if (this.vizSettings.percentileClip) {
                const values = [];
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        const val = matrix[order[i]][order[j]];
                        if (val > 0) values.push(val);
                    }
                }
                values.sort((a, b) => a - b);
                minValue = values[Math.floor(values.length * 0.05)] || 0;
                maxValue = values[Math.floor(values.length * 0.95)] || 100;
            }
            
            // Draw heatmap
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const value = matrix[order[i]][order[j]];
                    if (value > 0) {
                        ctx.fillStyle = this.getColor(value, minValue, maxValue);
                        ctx.fillRect(i * cellSize, j * cellSize, Math.ceil(cellSize), Math.ceil(cellSize));
                    }
                }
            }
            
            // Draw chromosome boundaries
            if (this.vizSettings.showGrid) {
                ctx.strokeStyle = '#6366f1';
                ctx.lineWidth = 2;
                
                let currentPos = 0;
                this.chromosomes.forEach(chr => {
                    const chrBins = this.getChromosomeBins(chr).length;
                    currentPos += chrBins;
                    
                    if (currentPos < size) {
                        ctx.beginPath();
                        ctx.moveTo(currentPos * cellSize, 0);
                        ctx.lineTo(currentPos * cellSize, canvas.height);
                        ctx.moveTo(0, currentPos * cellSize);
                        ctx.lineTo(canvas.width, currentPos * cellSize);
                        ctx.stroke();
                    }
                });
            }
            
            // Draw diagonal
            if (this.vizSettings.showDiagonal) {
                ctx.strokeStyle = '#ec4899';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(canvas.width, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        renderPsPlot() {
            const canvas = document.getElementById('ps-plot');
            const ctx = canvas.getContext('2d');
            const psData = this.currentState.psData;
            
            if (!psData || !psData.data.length) return;
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Clear canvas
            ctx.fillStyle = '#334155';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const padding = 40;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;
            
            const xMin = Math.log10(1);
            const xMax = Math.log10(Math.max(...psData.data.map(d => d.s)));
            const yMin = Math.log10(Math.min(...psData.data.filter(d => d.p > 0).map(d => d.p)));
            const yMax = Math.log10(Math.max(...psData.data.map(d => d.p)));
            
            // Draw axes
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Draw data points
            ctx.fillStyle = '#6366f1';
            psData.data.forEach(point => {
                if (point.p > 0) {
                    const x = padding + (Math.log10(point.s) - xMin) / (xMax - xMin) * plotWidth;
                    const y = canvas.height - padding - (Math.log10(point.p) - yMin) / (yMax - yMin) * plotHeight;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Draw power law fit
            ctx.strokeStyle = '#ec4899';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i <= 100; i++) {
                const logS = xMin + (xMax - xMin) * i / 100;
                const s = Math.pow(10, logS);
                const p = 100 * Math.pow(s, -psData.alpha);
                
                if (p > 0) {
                    const x = padding + (logS - xMin) / (xMax - xMin) * plotWidth;
                    const y = canvas.height - padding - (Math.log10(p) - yMin) / (yMax - yMin) * plotHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            }
            ctx.stroke();
        }
        
        getChromosomeBins(chr) {
            const bins = [];
            this.contactMap.binMap.forEach((binId, key) => {
                if (key.startsWith(chr + ':')) {
                    bins.push(binId);
                }
            });
            return bins.sort((a, b) => a - b);
        }
        
        handleMouseDown(e) {
            if (!this.currentState) return;
            
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            const cellSize = canvas.width / this.currentState.matrix.length;
            const binX = Math.floor(x / cellSize);
            const binY = Math.floor(y / cellSize);
            
            if (this.selectedTool === 'select') {
                this.selection = {
                    startX: binX,
                    startY: binY,
                    endX: binX,
                    endY: binY
                };
                this.isDragging = true;
            } else if (this.selection) {
                this.prepareOperation(binX, binY);
            }
        }
        
        handleMouseMove(e) {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            const cellSize = canvas.width / this.currentState.matrix.length;
            const binX = Math.floor(x / cellSize);
            const binY = Math.floor(y / cellSize);
            
            // Update hover info
            if (binX >= 0 && binX < this.currentState.matrix.length && 
                binY >= 0 && binY < this.currentState.matrix.length) {
                const value = this.currentState.matrix[this.currentState.binOrder[binX]][this.currentState.binOrder[binY]];
                
                const hoverInfo = document.getElementById('hover-info');
                hoverInfo.style.display = 'block';
                hoverInfo.style.left = (e.clientX - rect.left + 10) + 'px';
                hoverInfo.style.top = (e.clientY - rect.top + 10) + 'px';
                
                const realBinX = this.currentState.binOrder[binX];
                const realBinY = this.currentState.binOrder[binY];
                
                // Find chromosome for bins
                let chrX = '', chrY = '';
                let accumBins = 0;
                for (const chr of this.chromosomes) {
                    const chrBinCount = this.getChromosomeBins(chr).length;
                    if (realBinX >= accumBins && realBinX < accumBins + chrBinCount) {
                        chrX = chr;
                    }
                    if (realBinY >= accumBins && realBinY < accumBins + chrBinCount) {
                        chrY = chr;
                    }
                    accumBins += chrBinCount;
                }
                
                hoverInfo.querySelector('.hover-coords').textContent = `${chrX}:${binX} × ${chrY}:${binY}`;
                hoverInfo.querySelector('.hover-value').textContent = `Value: ${value.toFixed(2)}`;
            }
            
            // Update selection if dragging
            if (this.isDragging && this.selection) {
                this.selection.endX = binX;
                this.selection.endY = binY;
                this.updateSelectionOverlay();
            }
        }
        
        handleMouseUp(e) {
            if (this.isDragging) {
                this.isDragging = false;
                this.normalizeSelection();
                this.updateRegionInfo();
            }
        }
        
        hideHoverInfo() {
            document.getElementById('hover-info').style.display = 'none';
        }
        
        normalizeSelection() {
            if (!this.selection) return;
            
            const minX = Math.min(this.selection.startX, this.selection.endX);
            const maxX = Math.max(this.selection.startX, this.selection.endX);
            const minY = Math.min(this.selection.startY, this.selection.endY);
            const maxY = Math.max(this.selection.startY, this.selection.endY);
            
            this.selection = {
                x: minX,
                y: minY,
                width: maxX - minX + 1,
                height: maxY - minY + 1
            };
        }
        
        updateSelectionOverlay() {
            const overlay = document.getElementById('selection-overlay');
            const canvas = document.getElementById('heatmap-canvas');
            const cellSize = canvas.width / this.currentState.matrix.length;
            
            if (this.selection) {
                const minX = Math.min(this.selection.startX || this.selection.x, this.selection.endX || this.selection.x + this.selection.width - 1);
                const maxX = Math.max(this.selection.startX || this.selection.x, this.selection.endX || this.selection.x + this.selection.width - 1);
                const minY = Math.min(this.selection.startY || this.selection.y, this.selection.endY || this.selection.y + this.selection.height - 1);
                const maxY = Math.max(this.selection.startY || this.selection.y, this.selection.endY || this.selection.y + this.selection.height - 1);
                
                overlay.style.display = 'block';
                overlay.style.left = (minX * cellSize) + 'px';
                overlay.style.top = (minY * cellSize) + 'px';
                overlay.style.width = ((maxX - minX + 1) * cellSize) + 'px';
                overlay.style.height = ((maxY - minY + 1) * cellSize) + 'px';
            } else {
                overlay.style.display = 'none';
            }
        }
        
        updateRegionInfo() {
            const regionInfo = document.getElementById('region-info');
            
            if (!this.selection) {
                regionInfo.innerHTML = '<p style="color: var(--text-tertiary);">No region selected</p>';
                document.getElementById('operation-controls').style.display = 'none';
                return;
            }
            
            // Get chromosome info for selection
            const startBin = this.currentState.binOrder[this.selection.x];
            const endBin = this.currentState.binOrder[this.selection.x + this.selection.width - 1];
            
            let chrInfo = '';
            let accumBins = 0;
            for (const chr of this.chromosomes) {
                const chrBins = this.getChromosomeBins(chr);
                const chrStart = accumBins;
                const chrEnd = accumBins + chrBins.length;
                
                if (startBin >= chrStart && startBin < chrEnd) {
                    chrInfo = `${chr} (bins ${this.selection.x}-${this.selection.x + this.selection.width - 1})`;
                    break;
                }
                accumBins += chrBins.length;
            }
            
            regionInfo.innerHTML = `
                <h4>Selected Region</h4>
                <div class="region-details">
                    <div>Position: ${this.selection.x}, ${this.selection.y}</div>
                    <div>Size: ${this.selection.width} × ${this.selection.height}</div>
                    <div>Chromosome: ${chrInfo}</div>
                </div>
            `;
            
            // Show operation controls for certain tools
            if (['move', 'swap'].includes(this.selectedTool)) {
                document.getElementById('operation-controls').style.display = 'flex';
            } else {
                document.getElementById('operation-controls').style.display = 'none';
            }
        }
        
        prepareOperation(targetX, targetY) {
            switch (this.selectedTool) {
                case 'move':
                    this.pendingOperation = { type: 'move', targetX, targetY };
                    break;
                case 'swap':
                    if (!this.pendingOperation) {
                        this.pendingOperation = { type: 'swap', region1: {...this.selection} };
                        alert('Select second region to swap with');
                    } else {
                        this.pendingOperation.region2 = {...this.selection};
                        this.confirmOperation();
                    }
                    break;
                case 'invert':
                    this.performInversion();
                    break;
                case 'delete':
                    this.performDeletion();
                    break;
                case 'duplicate':
                    this.performDuplication();
                    break;
                case 'split':
                    this.performSplit();
                    break;
                case 'fuse':
                    this.performFusion();
                    break;
            }
        }
        
        confirmOperation() {
            if (!this.pendingOperation) return;
            
            switch (this.pendingOperation.type) {
                case 'move':
                    this.performMove(this.pendingOperation.targetX, this.pendingOperation.targetY);
                    break;
                case 'swap':
                    this.performSwap(this.pendingOperation.region1, this.pendingOperation.region2);
                    break;
            }
            
            this.pendingOperation = null;
            document.getElementById('operation-controls').style.display = 'none';
        }
        
        cancelOperation() {
            this.pendingOperation = null;
            this.selection = null;
            this.updateSelectionOverlay();
            this.updateRegionInfo();
        }
        
        performMove(targetX, targetY) {
            const startX = this.selection.x;
            const width = this.selection.width;
            
            const movedBins = this.currentState.binOrder.splice(startX, width);
            const insertPos = targetX > startX ? targetX - width : targetX;
            this.currentState.binOrder.splice(insertPos, 0, ...movedBins);
            
            this.calculatePsDistribution();
            this.calculateScore();
            this.saveToHistory(`Move ${width} bins from ${startX} to ${targetX}`);
            
            this.selection = null;
            this.updateSelectionOverlay();
            this.render();
        }
        
        performSwap(region1, region2) {
            const order = this.currentState.binOrder;
            
            // Extract regions
            const bins1 = order.slice(region1.x, region1.x + region1.width);
            const bins2 = order.slice(region2.x, region2.x + region2.width);
            
            // Perform swap
            if (region1.x < region2.x) {
                order.splice(region2.x, region2.width, ...bins1);
                order.splice(region1.x, region1.width, ...bins2);
            } else {
                order.splice(region1.x, region1.width, ...bins2);
                order.splice(region2.x, region2.width, ...bins1);
            }
            
            this.calculatePsDistribution();
            this.calculateScore();
            this.saveToHistory(`Swap regions ${region1.x}-${region1.x + region1.width} and ${region2.x}-${region2.x + region2.width}`);
            
            this.selection = null;
            this.updateSelectionOverlay();
            this.render();
        }
        
        performInversion() {
            const startX = this.selection.x;
            const width = this.selection.width;
            
            const invertedBins = this.currentState.binOrder.slice(startX, startX + width).reverse();
            this.currentState.binOrder.splice(startX, width, ...invertedBins);
            
            this.calculatePsDistribution();
            this.calculateScore();
            this.saveToHistory(`Invert ${width} bins at position ${startX}`);
            
            this.selection = null;
            this.updateSelectionOverlay();
            this.render();
        }
        
        performDeletion() {
            const startX = this.selection.x;
            const width = this.selection.width;
            
            this.currentState.binOrder.splice(startX, width);
            
            this.calculatePsDistribution();
            this.calculateScore();
            this.saveToHistory(`Delete ${width} bins at position ${startX}`);
            
            this.selection = null;
            this.updateSelectionOverlay();
            this.render();
        }
        
        performDuplication() {
            const startX = this.selection.x;
            const width = this.selection.width;
            
            const duplicatedBins = this.currentState.binOrder.slice(startX, startX + width);
            this.currentState.binOrder.splice(startX + width, 0, ...duplicatedBins);
            
            this.calculatePsDistribution();
            this.calculateScore();
            this.saveToHistory(`Duplicate ${width} bins at position ${startX}`);
            
            this.selection = null;
            this.updateSelectionOverlay();
            this.render();
        }
        
        performSplit() {
            // This is a placeholder - actual implementation would need to update chromosome boundaries
            alert('Split operation would create new chromosome boundary at this position');
            this.selection = null;
            this.updateSelectionOverlay();
        }
        
        performFusion() {
            // This is a placeholder - actual implementation would need to merge chromosome boundaries
            alert('Fusion operation would merge chromosomes in this region');
            this.selection = null;
            this.updateSelectionOverlay();
        }
        
        exportBed() {
            if (!this.currentState || !this.contactMap) {
                alert('No data to export');
                return;
            }
            
            const output = [];
            output.push('# Reassembled contact map');
            output.push('# Score: ' + this.currentState.score.toFixed(2));
            output.push('# Power law alpha: ' + (this.currentState.psData?.alpha.toFixed(3) || 'N/A'));
            output.push('# chr1\tstart1\tend1\tchr2\tstart2\tend2\tscore');
            
            // Export reordered matrix
            const order = this.currentState.binOrder;
            const matrix = this.currentState.matrix;
            
            for (let i = 0; i < order.length; i++) {
                for (let j = i; j < order.length; j++) {
                    if (matrix[order[i]][order[j]] > 0) {
                        output.push(`bin${i}\t${i * this.binSize}\t${(i + 1) * this.binSize}\tbin${j}\t${j * this.binSize}\t${(j + 1) * this.binSize}\t${matrix[order[i]][order[j]].toFixed(2)}`);
                    }
                }
            }
            
            this.downloadFile('reassembled_contacts.bed', output.join('\n'));
        }
        
        exportModifications() {
            const output = ['# Genome Reassembly Modification History'];
            output.push(`# Total modifications: ${this.history.length}`);
            output.push(`# Best score achieved: ${Math.max(...this.history.map(h => h.state.score))}`);
            output.push('');
            
            this.history.forEach((item, idx) => {
                output.push(`\nStep ${idx + 1}: ${item.description}`);
                output.push(`  Timestamp: ${new Date(item.timestamp).toLocaleString()}`);
                output.push(`  Score: ${item.state.score.toFixed(2)}`);
                output.push(`  Power law alpha: ${item.state.psAlpha?.toFixed(3) || 'N/A'}`);
            });
            
            this.downloadFile('modification_history.txt', output.join('\n'));
        }
        
        exportFasta() {
            if (!this.fastaData) {
                alert('No FASTA data loaded');
                return;
            }
            
            const output = [];
            output.push('; Reassembled genome');
            output.push('; Score: ' + this.currentState.score.toFixed(2));
            
            Object.entries(this.fastaData).forEach(([chr, seq]) => {
                output.push(`>${chr}_reassembled`);
                for (let i = 0; i < seq.length; i += 80) {
                    output.push(seq.slice(i, i + 80));
                }
            });
            
            this.downloadFile('reassembled_genome.fasta', output.join('\n'));
        }
        
        exportMatrix() {
            if (!this.currentState) {
                alert('No data to export');
                return;
            }
            
            const order = this.currentState.binOrder;
            const matrix = this.currentState.matrix;
            const output = [];
            
            for (let i = 0; i < order.length; i++) {
                const row = [];
                for (let j = 0; j < order.length; j++) {
                    row.push(matrix[order[i]][order[j]].toFixed(2));
                }
                output.push(row.join('\t'));
            }
            
            this.downloadFile('reassembled_matrix.tsv', output.join('\n'));
        }
        
        downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        showLoading() {
            document.getElementById('loading').style.display = 'flex';
        }
        
        hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }
    }
    
    // Initialize the tool
    document.addEventListener('DOMContentLoaded', () => {
        window.genomeReassemblyTool = new GenomeReassemblyTool();
    });
    </script>
</body>
</html>